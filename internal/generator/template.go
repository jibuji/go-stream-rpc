package generator

import (
	"text/template"
)

var clientStubTemplate = template.Must(template.New("client").Parse(`
// Code generated by stream-rpc. DO NOT EDIT.
package {{.PackageName}}

import (
	rpc "stream-rpc"
)

type {{.ServiceName}}Client struct {
	peer *rpc.RpcPeer
}

func New{{.ServiceName}}Client(peer *rpc.RpcPeer) *{{.ServiceName}}Client {
	return &{{.ServiceName}}Client{peer: peer}
}

{{range .Methods}}
func (c *{{$.ServiceName}}Client) {{.Name}}(req *{{.InputType}}) (*{{.OutputType}}, error) {
	resp := &{{.OutputType}}{}
	err := c.peer.Call("{{$.ServiceName}}.{{.Name}}", req, resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
{{end}}
`))

var serverStubTemplate = template.Must(template.New("server").Parse(`
// Code generated by stream-rpc. DO NOT EDIT.
package {{.PackageName}}

import (
	rpc "stream-rpc"
)

// UnimplementedCalculatorServer can be embedded to have forward compatible implementations
type Unimplemented{{.ServiceName}}Server struct {}

{{range .Methods}}
func (s *Unimplemented{{$.ServiceName}}Server) {{.Name}}(*{{.InputType}}) (*{{.OutputType}}, error) {
	return nil, rpc.ErrNotImplemented
}
{{end}}

type {{.ServiceName}}Server interface {
	{{range .Methods}}
	{{.Name}}(*{{.InputType}}) (*{{.OutputType}}, error)
	{{end}}
}

type {{.ServiceName}}ServerImpl struct {
	impl {{.ServiceName}}Server
}

func Register{{.ServiceName}}Server(peer *rpc.RpcPeer, impl {{.ServiceName}}Server) {
	server := &{{.ServiceName}}ServerImpl{impl: impl}
	peer.RegisterService("{{.ServiceName}}", server)
}

{{range .Methods}}
func (s *{{$.ServiceName}}ServerImpl) {{.Name}}(req *{{.InputType}}) (*{{.OutputType}}, error) {
	return s.impl.{{.Name}}(req)
}
{{end}}
`))
